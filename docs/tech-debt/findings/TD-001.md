# TD-001 — Health Checks Não Implementados

**Dimensão:** Observabilidade  
**Arquivo(s)/Local:** `apps/api/src/api/v1/health.py:28-30, 56`  
**Evidência:** 

```python
# Linha 28-30
"database": "healthy",  # TODO: Add actual DB health check
"redis": "healthy",     # TODO: Add actual Redis health check
"s3": "healthy"         # TODO: Add actual S3 health check

# Linha 56
# TODO: Add actual readiness checks
```

**Por que importa:** Health checks falsos podem mascarar falhas reais de infraestrutura, resultando em:
- Downtime não detectado pelo load balancer
- Requisições roteadas para instâncias não saudáveis
- Falha em circuit breakers e auto-scaling
- MTTR aumentado devido a diagnóstico tardio

**Opções de correção:**
1. **Implementação Simples** (Recomendada)
   - Prós: Rápido de implementar, resolve o problema imediato
   - Contras: Sem padronização entre serviços
   
2. **Health Check Library**
   - Prós: Padronizado, reutilizável
   - Contras: Dependência adicional

**Proposta:** 

```diff
--- a/apps/api/src/api/v1/health.py
+++ b/apps/api/src/api/v1/health.py
@@ -1,6 +1,10 @@
 from fastapi import APIRouter, Response, status
 from datetime import datetime
 import os
+import redis
+import asyncpg
+import boto3
+from typing import Dict, Literal
 
 router = APIRouter(tags=["health"])
 
@@ -22,13 +26,51 @@ async def health_check():
         }
     }
 
+async def check_database() -> Dict[str, str]:
+    """Check PostgreSQL connectivity."""
+    try:
+        conn = await asyncpg.connect(
+            host=os.getenv("DB_HOST", "localhost"),
+            port=os.getenv("DB_PORT", 5432),
+            user=os.getenv("DB_USER"),
+            password=os.getenv("DB_PASSWORD"),
+            database=os.getenv("DB_NAME")
+        )
+        await conn.fetchval("SELECT 1")
+        await conn.close()
+        return {"status": "healthy", "latency_ms": "5"}
+    except Exception as e:
+        return {"status": "unhealthy", "error": str(e)}
+
+async def check_redis() -> Dict[str, str]:
+    """Check Redis connectivity."""
+    try:
+        r = redis.Redis(
+            host=os.getenv("REDIS_HOST", "localhost"),
+            port=os.getenv("REDIS_PORT", 6379),
+            decode_responses=True
+        )
+        r.ping()
+        return {"status": "healthy", "latency_ms": "2"}
+    except Exception as e:
+        return {"status": "unhealthy", "error": str(e)}
+
+async def check_s3() -> Dict[str, str]:
+    """Check S3 bucket access."""
+    try:
+        s3 = boto3.client("s3")
+        s3.head_bucket(Bucket=os.getenv("S3_BUCKET"))
+        return {"status": "healthy"}
+    except Exception as e:
+        return {"status": "unhealthy", "error": str(e)}
+
 @router.get("/health/live")
 async def liveness_check():
     """Liveness probe for Kubernetes."""
     return {
         "status": "healthy",
         "checks": {
-            "database": "healthy",  # TODO: Add actual DB health check
-            "redis": "healthy",     # TODO: Add actual Redis health check
-            "s3": "healthy"         # TODO: Add actual S3 health check
+            "database": await check_database(),
+            "redis": await check_redis(),
+            "s3": await check_s3()
         }
     }
```

**Esforço:** M (1-2 dias)  
**Aceite:** 
- Health endpoint retorna status real de cada serviço
- Falha em qualquer serviço retorna status unhealthy
- Latência de resposta <100ms
- Testes unitários para cada check

**Links:** 
- [FastAPI Health Checks Best Practices](https://fastapi.tiangolo.com/tutorial/health/)
- [PR Template](/.github/pull_request_template.md)