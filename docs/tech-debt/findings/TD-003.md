# TD-003 — Rate Limiting Não Funcional

**Dimensão:** Segurança  
**Arquivo(s)/Local:** `apps/api/src/middleware/correlation.py:58-61`  
**Evidência:**

```python
# Linha 58-61
# TODO: Implement actual rate limiting with Redis
# For now, just add headers
# TODO: Check rate limits
response.headers["X-RateLimit-Limit"] = "100"
```

**Por que importa:**
- **Vulnerabilidade DDoS**: Sem proteção contra flood de requisições
- **Abuso de recursos**: Um cliente pode monopolizar a API
- **Custos descontrolados**: Uso excessivo de recursos compute/storage
- **Degradação de performance**: Afeta todos os usuários
- **Compliance**: Muitos frameworks de segurança exigem rate limiting

**Opções de correção:**

1. **slowapi + Redis** (Recomendada)
   - Prós: Integração nativa com FastAPI, distribuído
   - Contras: Requer Redis
   
2. **nginx rate limiting**
   - Prós: Performance, sem mudança no código
   - Contras: Não distribuído, menos flexível

3. **API Gateway (AWS/Kong)**
   - Prós: Solução completa, features extras
   - Contras: Vendor lock-in, custo

**Proposta:**

```diff
--- a/apps/api/requirements.txt
+++ b/apps/api/requirements.txt
@@ -15,3 +15,5 @@
 pandas==2.0.3
 openpyxl==3.1.2
 chardet==5.2.0
+slowapi==0.1.9
+redis==5.0.1

--- a/apps/api/src/middleware/correlation.py
+++ b/apps/api/src/middleware/correlation.py
@@ -1,9 +1,14 @@
 from fastapi import Request, Response
 from starlette.middleware.base import BaseHTTPMiddleware
 import uuid
 import time
 import logging
+from slowapi import Limiter, _rate_limit_exceeded_handler
+from slowapi.util import get_remote_address
+from slowapi.errors import RateLimitExceeded
+from slowapi.middleware import SlowAPIMiddleware
+import redis
 
 logger = logging.getLogger(__name__)
 
@@ -55,11 +60,42 @@ class CorrelationMiddleware(BaseHTTPMiddleware):
         response.headers["X-Request-ID"] = correlation_id
         response.headers["X-Response-Time"] = str(process_time)
         
-        # TODO: Implement actual rate limiting with Redis
-        # For now, just add headers
-        # TODO: Check rate limits
-        response.headers["X-RateLimit-Limit"] = "100"
-        response.headers["X-RateLimit-Remaining"] = "99"
-        response.headers["X-RateLimit-Reset"] = str(int(time.time()) + 3600)
-        
         return response
+
+--- /dev/null
+++ b/apps/api/src/middleware/rate_limit.py
@@ -0,0 +1,74 @@
+from slowapi import Limiter
+from slowapi.util import get_remote_address
+from slowapi.errors import RateLimitExceeded
+from fastapi import Request, HTTPException
+from fastapi.responses import JSONResponse
+import redis
+import os
+from typing import Optional
+
+# Initialize Redis connection
+redis_client = redis.Redis(
+    host=os.getenv("REDIS_HOST", "localhost"),
+    port=int(os.getenv("REDIS_PORT", 6379)),
+    db=0,
+    decode_responses=True
+)
+
+def get_client_id(request: Request) -> str:
+    """
+    Get client identifier for rate limiting.
+    Uses API key if present, otherwise IP address.
+    """
+    # Check for API key
+    api_key = request.headers.get("X-API-Key")
+    if api_key:
+        return f"key:{api_key}"
+    
+    # Fall back to IP
+    return f"ip:{get_remote_address(request)}"
+
+# Create limiter with Redis storage
+limiter = Limiter(
+    key_func=get_client_id,
+    storage_uri=os.getenv("REDIS_URL", "redis://localhost:6379"),
+    default_limits=["100 per hour", "10 per minute"]
+)
+
+async def rate_limit_exceeded_handler(
+    request: Request,
+    exc: RateLimitExceeded
+) -> JSONResponse:
+    """Custom handler for rate limit exceeded."""
+    response = JSONResponse(
+        status_code=429,
+        content={
+            "error": "rate_limit_exceeded",
+            "message": f"Rate limit exceeded: {exc.detail}",
+            "retry_after": exc.retry_after
+        }
+    )
+    response.headers["Retry-After"] = str(exc.retry_after)
+    response.headers["X-RateLimit-Limit"] = str(exc.limit)
+    response.headers["X-RateLimit-Remaining"] = "0"
+    response.headers["X-RateLimit-Reset"] = str(exc.reset_after)
+    return response
+
+# Endpoint-specific limits
+validation_limiter = limiter.limit("5 per minute")
+health_limiter = limiter.limit("30 per minute")
+async_limiter = limiter.limit("2 per minute")

--- a/apps/api/src/main.py
+++ b/apps/api/src/main.py
@@ -4,6 +4,8 @@
 from contextlib import asynccontextmanager
 import logging
 from .middleware.correlation import CorrelationMiddleware
+from .middleware.rate_limit import limiter, rate_limit_exceeded_handler
+from slowapi.errors import RateLimitExceeded
 
 # ... existing imports ...
 
@@ -40,6 +42,12 @@ app = FastAPI(
 
 # Add correlation middleware
 app.add_middleware(CorrelationMiddleware)
+
+# Add rate limiting
+app.state.limiter = limiter
+app.add_exception_handler(RateLimitExceeded, rate_limit_exceeded_handler)
+
+# ... rest of the code ...

--- a/apps/api/src/api/v1/validation.py
+++ b/apps/api/src/api/v1/validation.py
@@ -18,6 +18,7 @@
 from fastapi.responses import StreamingResponse, JSONResponse
 from typing import Optional, Dict, Any, Union
 import io
+from ...middleware.rate_limit import validation_limiter, async_limiter
 
 # ... existing imports ...
 
@@ -63,6 +64,7 @@ def get_rate_limit_headers(request: Request) -> Dict[str, str]:
 
 @router.post("/validate")
+@validation_limiter
 async def validate_csv(
     request: Request,
     file: UploadFile = File(...),
@@ -640,6 +642,7 @@ async def correct_csv_auto(
 
 
 @router.post("/validate/async")
+@async_limiter
 async def validate_csv_async(
     request: Request,
     file: UploadFile = File(...),
```

**Esforço:** M (2 dias)  
**Aceite:**
- Rate limiting funcional por IP e API key
- Headers informativos em todas as respostas
- Resposta 429 com retry-after
- Limites configuráveis por endpoint
- Testes de rate limiting passando
- Redis como storage distribuído

**Links:**
- [SlowAPI Documentation](https://slowapi.readthedocs.io/)
- [OWASP Rate Limiting](https://owasp.org/www-community/controls/Rate_Limiting)